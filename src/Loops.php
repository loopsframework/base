<?php
/**
 * This file is part of the Loops framework.
 *
 * @author Lukas <lukas@loopsframework.com>
 * @license https://raw.githubusercontent.com/loopsframework/base/master/LICENSE
 * @link https://github.com/loopsframework/base
 * @link https://loopsframework.com/
 * @version 0.1
 */

use Loops\Misc;
use Loops\Object;
use Loops\ArrayObject;
use Loops\Config\ArrayConfig;
use Loops\Annotations\Access\ReadOnly;

/**
 * The Loops Context
 *
 * The dependency injection class in the Loops framework that provides access to Loops services.
 * Services can be either registered by the registerService method or will be automatically created from classes in the Loops\Service namespace.
 */
class Loops extends Object {
    const VERSION = "0.1";
    
    /**
     * @var Loops The latest context that has been created.
     */
    private static $current_loops;

    /**
     * @var ArrayAccess The config directives that are used by this Loops context.
     */
    private $config;
    
    private $services = [];
    private $shared_instances = [];
    
    /**
     * @var bool Specifies if loops runs in debug mode
     * @ReadOnly
     */
    protected $debug;
    
    /**
     * Creates the Loops Context
     *
     * Values from the passed config object will be used when creating services on the fly (see getService).
     * The configuration should be stored in keys that are identical to service names.
     *
     * The config file will be made accessible as a service under the name 'config'.
     *
     * @param Loops\ArrayObject $serviceconfig The configuration will be used when creating services.
     */
    public function __construct(ArrayObject $config, $debug = TRUE) {
        $this->config = $config;
        $this->debug = $debug;
        
        Loops::$current_loops = $this;
        
        parent::__construct($this);
        
        $this->registerService("config", $config);
    }
    
    /**
     * Checks if a service exists
     *
     * @param string $name The name of the service
     * @param bool $resolve Specified if Loops should try to resolve unloaded services from the Loops\Service namespace.
     * @return bool TRUE if the service is registered (or can be created from the Loops\Service namespace if $resolve is TRUE, see getService for details)
     */
    public function hasService($name, $resolve = TRUE) {
        if(array_key_exists($name, $this->services)) {
            return TRUE;
        }
        
        if(!$resolve) {
            return FALSE;
        }
        
        $classname = "Loops\\Service\\".Misc::camelize($name);
        
        if(class_exists($classname)) {
            $reflection = new ReflectionClass($classname);
            
            if($reflection->implementsInterface("Loops\ServiceInterface")) {
                if(!$classname::hasService($this)) {
                    return FALSE;
                }
                $this->registerService($name, $classname, [], $classname::isShared($this));
            }
        }
        
        return $this->hasService($name, FALSE);
    }
    
    /**
     * Returns a service
     *
     * The requested service will be returned. If a service is shared (see Loops\Service\Service for details) the same instance will be returned on subsequent calls.
     * If a service has not been registered, Loops tries to find the service in the "Loops\Service" namespace. The classname is generated by camelizing (see Loops\Misc::camelize) the passed name.
     *
     * @param $name The service name
     * @return Loops\Service\ServiceInterface The requested service
     */
    public function getService($name) {
        if(!$this->hasService($name)) {
            throw new Exception("Service '$name' does not exist.");
        }
        
        if(array_key_exists($name, $this->shared_instances)) {
            return $this->shared_instances[$name];
        }
        
        $service = $this->createService($name, NULL, TRUE);
        
        if($this->services[$name]["shared"]) {
            $this->shared_instances[$name] = $service;
        }

        return $service;
    }
    
    /**
     * Creates a new instance of a service
     *
     * @param $name The service name
     * @param array $config
     * @return Loops\Service\ServiceInterface The new service
     */
    public function createService($name, ArrayObject $config = NULL, $merge_into_config = FALSE) {
        if($merge_into_config) {
            $service_config = $this->config->offsetExists($name) ? $this->config->offsetGet($name) : new ArrayObject;
        
            if(is_array($service_config)) {
                $service_config = ArrayObject::fromArray($service_config);
            }
            
            if($config) {
                $service_config->merge($config);
            }
        }
        else {
            $service_config = $config ?: new ArrayObject;
        }
        
        if(!$this->hasService($name)) {
            throw new Exception("Service '$name' does not exist.");
        }
        
        $service = $this->services[$name];
        
        if(array_key_exists("classname", $service)) {
            $reflection = new ReflectionClass($service["classname"]);
            
            $params = new ArrayObject($service["params"]);
            $params->merge($service_config);
            
            if($reflection->implementsInterface("Loops\ServiceInterface")) {
                return call_user_func_array([$service["classname"], "getService" ], [ $params, $this ]);
            }
            else {
                $params->offsetSet("loops", $this);
                return Misc::reflectionInstance($service["classname"], $params);
            }
        }
        
        if(array_key_exists("callback", $service)) {
            $params = new ArrayObject($service["params"]);
            $params->merge($service_config);
            return call_user_func_array($service["callback"], $params->toArray());
        }
        
        if(array_key_exists("object", $service)) {
            return $service["object"];
        }
    }
    
    /**
     * Registers a custom Service
     *
     * @param string $name The service name
     * @param mixed $service A service class name as string, a callable (which returns the service) or an Object that is the service itself.
     * @param array $params If $service is a string/callable: Parameters that are passed to the constructor/callable when the service is created.
     * @param bool $shared If the service is a string/callable, specify if the service should be shared.
     */
    public function registerService($name, $service, array $params = [], $shared = TRUE) {
        if(is_callable($service)) {
            $this->services[$name] = [ "shared" => $shared, "params" => $params, "callback" => $service ];
        }
        elseif(is_object($service)) {
            $this->services[$name] = [ "shared" => $shared, "object" => $service ];
        }
        elseif(is_string($service)) {
            $this->services[$name] = [ "shared" => $shared, "params" => $params, "classname" => $service ];
        }
        else {
            throw new Exception("Failed to register service.");
        }
    }
    
    /**
     * Returns the current default Context
     *
     * This will be the latest created instance of this class.
     * Normally, only a single context is created during a request.
     *
     * @return Loops\Context The current context
     */
    public static function getCurrentLoops() {
        if(!self::$current_loops) {
            throw new Exception("No Loops Context was created yet.");
        }
        
        return self::$current_loops;
    }
}